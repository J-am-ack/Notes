1.容器适配器不提供迭代器
2.set的insert成员函数返回值是pair<iterator, bool>
Set的insert方法确实返回pair<iterator, bool>，其中迭代器指向插入的元素，bool表示插入是否成功。
3.所有适用于vector的算法（STL的函数模板）都适用于deque
(均支持随机迭代器)
4.不可修改multiset中的元素
Multiset中元素的键值不可修改，但若元素包含mutable成员，则该成员可修改。
5.析构函数不能被重载
6.打开文件时，如果文件不存在，系统会自动创建一个新文件。x只有部分打开方式，例如ios::out
可以用 ios::binary 模式打开文本文件进行读写
cin和cout是预定义的流对象，分别用于从标准输入读取和向标准输出写入数据，它们都是文件流对象。x与标准输入输出设备（通常是键盘和显示器）相关联的流对象
istream和ostream是基类，cin和cout是它们的派生类对象。x该类的对象

在编程中，流对象是用于处理数据输入和输出的抽象概念。数据流动的过程类似于水流，从一个地方流动到另一个地方，因此被称为“流”。流对象在输入源和输出目标之间充当桥梁的作用。

流的分类

流对象可以根据操作的数据类型和来源分为几类：

控制台流（iostream）：用于处理控制台输入输出的流对象。常见的控制台流对象有： cin：标准输入流，用于从键盘读取数据。 cout：标准输出流，用于向屏幕输出数据。 cerr：标准错误输出流，不带缓冲区，直接向屏幕输出错误信息。 clog：带缓冲区的错误输出流，输出的信息会先存放到缓冲区，缓冲区满或刷新时才输出到屏幕^1^。

文件流（fstream）：用于处理文件输入输出的流对象。常见的文件流类有： ifstream：用于从文件读取数据。 ofstream：用于向文件写入数据。 fstream：既能从文件读取数据，又能向文件写入数据^2^。

字符串流（sstream）：用于处理字符串输入输出的流对象。常见的字符串流类有： istringstream：用于从字符串读取数据。 ostringstream：用于向字符串写入数据。 stringstream：既能从字符串读取数据，又能向字符串写入数据^2^。

7.指针可以值为NULL，但引用必须始终引用一个变量。
8.指针可以被重新赋值以指向另一个对象，但引用一旦初始化后就不能将其改为引用别的变量。//非常引用可以通过引用修改所引用的对象的值，但引用的仍然是初始的变量
9.常量指针：指针的地址可以修改，但是不能通过常量指针修改该指针指向的值（即指针指向常量）`const int* p`
指针常量：指针的地址是常量`int* const p`
10.静态成员函数内部不能访问同类的非静态成员变量, 也不能调用同类的非静态成员函数。
//否则不能确定调用的参数属于哪一个对象
静态成员函数中可以使用this指针。x（无隐藏传参*this,也没有权限）
一个类可以有多个构造函数，但最多只能有一个析构函数。
析构函数只能有一个：
无参数，无法重载：析构函数没有参数，因此无法通过参数列表区分不同的实现。

唯一性语义：对象的销毁逻辑应当是唯一的，确保资源释放的确定性。

语法强制约束：析构函数必须命名为 ~类名()，且不能接受参数。

11.Alice同学希望创建一个priority_queue用来维护自定义类A的对象，为此她细心地给没有重载任何运算符的类A重载了>运算符。x //<
重载"<"更稳妥

Bob同学希望创建一个map用来实现int到vector<int>的映射，但是他忘记了重载运算符来比较两个vector。比较key！
x(int)作为key可以自动比较

Carol同学希望在一个排好序的vector(记作vv)中查找第一个大于等于x的数字（如果不存在输出-1），她不想写太多代码，于是直接输出了*lower_bound(vv.begin(),vv.end(),x)。//检查vv.end()！
需要注意end()
auto it = std::lower_bound(vv.begin(), vv.end(), x);
if (it != vv.end()) {
    std::cout << *it;
} else {
    std::cout << -1;
}

Dave同学希望将一个list(记作lst)从小到大排序，刚学会std::sort的他不假思索地写下了std::sort(lst.begin(),lst.end())。x:
list有自己的sort,而std：：sort是全局函数，需要指定排序规则。

12.构造、析构中可以使用this指针
编译器总是会给每个类生成一个默认的无参数的构造函数。X
